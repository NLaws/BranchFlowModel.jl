<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · BranchFlowModel</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BranchFlowModel</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">User Documentation</a></li><li class="is-active"><a class="tocitem" href>Methods</a></li><li><a class="tocitem" href="../math/">Math</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NLaws/BranchFlowModel.jl/blob/main/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h1><p>Some various methods used in BranchFlowModel.jl:</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This list of exported methods may not be up to date and there are missing doc strings. Contributions are welcome via fork and pull request.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Inputs(::String, ::String)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.Inputs-Tuple{AbstractVector{&lt;:Tuple}, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:AbstractVector}, String}" href="#CommonOPF.Inputs-Tuple{AbstractVector{&lt;:Tuple}, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:AbstractVector}, String}"><code>CommonOPF.Inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Inputs(
    edges::Array{Tuple}, 
    linecodes::Array{String}, 
    linelengths::Array{Float64}, 
    phases::Vector{Vector},
    substation_bus::String;
    Pload, 
    Qload, 
    Sbase=1, 
    Vbase=1, 
    Zdict, 
    v0, 
    v_lolim=0.95, 
    v_uplim=1.05,
    Ntimesteps=1, 
    P_up_bound=1e4,
    Q_up_bound=1e4,
    P_lo_bound=-1e4,
    Q_lo_bound=-1e4,
    Isquared_up_bounds=Dict{String, Float64}(),
    relaxed=true
)</code></pre><p>Lowest level Inputs constructor (the only one that returns the Inputs struct). </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The real and reactive loads provided are normalized using <code>Sbase</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.singlephase38linesInputs" href="#CommonOPF.singlephase38linesInputs"><code>CommonOPF.singlephase38linesInputs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">singlephase38linesInputs(;
    Pload=Dict{String, AbstractArray{Real, 1}}(), 
    Qload=Dict{String, AbstractArray{Real, 1}}(), 
    T=24,
    loadnodes = [&quot;3&quot;, &quot;5&quot;, &quot;36&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;15&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;22&quot;, &quot;25&quot;, 
                &quot;27&quot;, &quot;28&quot;, &quot;30&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;],
    Sbase = 1e6,
    Vbase = 12.5e3,
    v0=1.0,
    v_uplim = 1.05,
    v_lolim = 0.95,
)</code></pre><p>Convenience function for creating a single phase network with 38 lines and nodes.  Taken from: Andrianesis et al. 2019 &quot;Locational Marginal Value of Distributed Energy Resources as Non-Wires Alternatives&quot;</p><p>NOTE that Inputs is a mutable struct (s.t. loads can be added later).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.dsstxt_to_sparse_array" href="#CommonOPF.dsstxt_to_sparse_array"><code>CommonOPF.dsstxt_to_sparse_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dsstxt_to_sparse_array(fp::String, first_data_row::Int = 5)</code></pre><p>convert a SystemY.txt file from OpenDSS to a julia matrix. assumes that Y is symmetric.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>dss_files_to_dict</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.build_model!-Tuple{AbstractModel, Inputs{SinglePhase}}" href="#BranchFlowModel.build_model!-Tuple{AbstractModel, Inputs{SinglePhase}}"><code>BranchFlowModel.build_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_model!(m::JuMP.AbstractModel, p::Inputs{SinglePhase})</code></pre><p>Add variables and constraints to <code>m</code> using the values in <code>p</code>. Calls the following functions:</p><pre><code class="language-julia hljs">add_variables(m, p)
constrain_power_balance(m, p)
constrain_substation_voltage(m, p)
constrain_KVL(m, p)
constrain_cone(m, p)
constrain_loads(m, p)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_single_phase.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.build_model!-Tuple{AbstractModel, Inputs{MultiPhase}}" href="#BranchFlowModel.build_model!-Tuple{AbstractModel, Inputs{MultiPhase}}"><code>BranchFlowModel.build_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_model!(m::JuMP.AbstractModel, p::Inputs{MultiPhase})</code></pre><p>Add variables and constraints to <code>m</code> using the values in <code>p</code>. Calls the following functions:</p><pre><code class="language-julia hljs">add_variables(m, p)
constrain_power_balance(m, p)
constrain_substation_voltage(m, p)
constrain_KVL(m, p)
constrain_loads(m, p)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_multi_phase.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.add_variables" href="#BranchFlowModel.add_variables"><code>BranchFlowModel.add_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_variables(m, p::Inputs{MultiPhase})</code></pre><p>Create complex variables:</p><ul><li><code>m[:w]</code> are 3x3 Hermitian matrices of voltage squared (V*V^T)</li><li><code>m[:l]</code> are 3x3 Hermitian matrices of current squared (I*I^T)</li><li><code>m[:Sj]</code> are 3x1 matrices of net power injections (at bus j)</li><li><code>m[:Sij]</code> are 3x3 Complex matrices of line flow powers (from i to j)</li></ul><p>The positive semi-definite constraints are also defined and stored as</p><ul><li><code>m[:H][t][j]</code> where <code>t</code> is time step and <code>j</code> is the bus name.</li></ul><p>All of the variable containers have typeof <code>Dict{Int, Dict{String, AbstractVecOrMat}}</code>`.</p><ul><li>The first index is time step (integer)</li><li>The second index is bus or line (string)</li><li>and finally a matrix of complex variables</li></ul><p>Some examples of using variables:</p><pre><code class="language-julia hljs">
value.(m[:Sj][1][&quot;671&quot;])

value(variable_by_name(m, &quot;real(Sj_1_671_1)&quot;))

value.(m[:w][1][&quot;671&quot;])

value.(m[:Sj][1][p.substation_bus]) 

for b in keys(p.Pload)
    println(b, &quot;  &quot;, value.(m[:Sj][1][b]))
end

fix(variable_by_name(m, &quot;real(Sj_1_645_3)&quot;), 0.0, force=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_multi_phase.jl#L26-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.constrain_power_balance" href="#BranchFlowModel.constrain_power_balance"><code>BranchFlowModel.constrain_power_balance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function constrain_power_balance(m, p::Inputs)</code></pre><p>Pij in - losses == sum of line flows out + net injection NOTE: using sum over Pij for future expansion to mesh grids i -&gt; j -&gt; k</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_single_phase.jl#L57-L63">source</a></section><section><div><pre><code class="nohighlight hljs">function constrain_power_balance(m, p::Inputs{MultiPhase})</code></pre><p>Sij in - losses == sum of line flows out + net injection NOTE: using sum over Pij for future expansion to mesh grids i -&gt; j -&gt; k</p><p>All of the power balance constraints are stored in <code>m[:loadbalcons]</code> with the bus name (string) as the first index. For example <code>m[:loadbalcons][&quot;busname&quot;]</code> will give the constrain container from JuMP for all time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_multi_phase.jl#L224-L234">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>constrain_substation_voltage</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.constrain_KVL" href="#BranchFlowModel.constrain_KVL"><code>BranchFlowModel.constrain_KVL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constrain_KVL(m, p::Inputs{MultiPhase})</code></pre><p>Add the voltage drop definintions between busses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_multi_phase.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.constrain_loads" href="#BranchFlowModel.constrain_loads"><code>BranchFlowModel.constrain_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constrain_loads(m, p::Inputs)</code></pre><ul><li>set net injections Pj/Qj to negative of Inputs.Pload/Qload, which are normalized by Sbase when creating Inputs</li><li>keys of P/Qload must match Inputs.busses. Any missing keys have load set to zero.</li><li>Inputs.substation_bus is unconstrained, slack bus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_single_phase.jl#L213-L219">source</a></section><section><div><pre><code class="nohighlight hljs">constrain_loads(m, p::Inputs{MultiPhase})</code></pre><ul><li>set loads to negative of Inputs.Pload and Inputs.Qload,    which are normalized by Sbase when creating Inputs.</li><li>keys of Pload and Qload must match Inputs.busses. Any missing keys have load set to zero.</li><li>Inputs.substation_bus is unconstrained, slack bus</li></ul><p>Each of the power injection constraints are stored in the model under <code>m[:injectioncons]</code>. To acces the constraints you can:</p><pre><code class="language-julia hljs">m[:injectioncons][&quot;busname&quot;][t,phs]</code></pre><p>where <code>t</code> is the integer time step and <code>phs</code> is the integer phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/model_multi_phase.jl#L321-L335">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>constrain_bounds</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.check_rank_one" href="#BranchFlowModel.check_rank_one"><code>BranchFlowModel.check_rank_one</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_rank_one(m::JuMP.AbstractModel, p::Inputs{BranchFlowModel.MultiPhase}, tol=1e-3)</code></pre><p>Check the rank of the <code>m[:H]</code> matrices from the PSD cone constraints. Warnings express any values with rank greater than one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/checks.jl#L24-L29">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_bus_values</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_edge_values</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_ijlinecode</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_ijlinelength</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.get_ij_idx" href="#CommonOPF.get_ij_idx"><code>CommonOPF.get_ij_idx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ij_idx(i::AbstractString, j::AbstractString, p::Inputs)</code></pre><p>get the index for edge i-&gt;j in the <code>Inputs</code><code>edge vectors:</code>edges<code>,</code>linecodes<code>,</code>phases<code>,</code>edge_keys<code>, and</code>linelengths`</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.i_to_j" href="#CommonOPF.i_to_j"><code>CommonOPF.i_to_j</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function i_to_j(j::AbstractString, p::Inputs)</code></pre><p>find all busses upstream of bus j</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In a radial network this function should return an Array with length of 1.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.j_to_k" href="#CommonOPF.j_to_k"><code>CommonOPF.j_to_k</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function j_to_k(j::AbstractString, p::Inputs)</code></pre><p>find all busses downstream of bus j</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.rij" href="#BranchFlowModel.rij"><code>BranchFlowModel.rij</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})</code></pre><p>The per-unit resistance of line i-&gt;j</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.xij" href="#BranchFlowModel.xij"><code>BranchFlowModel.xij</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">xij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})</code></pre><p>The per-unit reacttance of line i-&gt;j</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L14-L18">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>zij</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.check_soc_inequalities" href="#BranchFlowModel.check_soc_inequalities"><code>BranchFlowModel.check_soc_inequalities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_soc_inequalities(m::JuMP.AbstractModel, p::Inputs)</code></pre><p>create and return a vector of the gaps in the second order cone constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/checks.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.check_connected_graph" href="#BranchFlowModel.check_connected_graph"><code>BranchFlowModel.check_connected_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_connected_graph(p::Inputs{SinglePhase})</code></pre><p>return true if only one connected graph; false otherwise</p><p>this is a good check to do before attempting to solve a model because if there is more than one sub-graph then it is likely the model will be infeasible</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/checks.jl#L43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.get_load_bal_shadow_prices" href="#BranchFlowModel.get_load_bal_shadow_prices"><code>BranchFlowModel.get_load_bal_shadow_prices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_load_bal_shadow_prices(m::JuMP.AbstractModel, p::Inputs)</code></pre><p>create and return a dict indexed by bus and time for shadow prices     (just real prices for now)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L255-L260">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>voltage_values_by_time_bus</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>current_values_by_time_edge</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>line_flow_values_by_time_edge</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.reduce_tree!" href="#BranchFlowModel.reduce_tree!"><code>BranchFlowModel.reduce_tree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reduce_tree!(p::Inputs{SinglePhase})</code></pre><p>combine any line sets with intermediate busses that have indegree == outdegree == 1 and is not a load bus into a single line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/inputs.jl#L1-L6">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>trim_tree!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.make_graph" href="#CommonOPF.make_graph"><code>CommonOPF.make_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_graph(busses::AbstractVector{String}, edges::AbstractVector)</code></pre><p>return SimpleDiGraph, Dict, Dict  with the dicts for bus =&gt; int and int =&gt; bus (because Graphs.jl only works with integer nodes)</p><pre><code class="language-julia hljs">julia&gt; g[&quot;13&quot;, :bus]
10

julia&gt; get_prop(g, :bus_int_map)[&quot;13&quot;]
10

julia&gt; g[13, :bus]
&quot;24&quot;

julia&gt; get_prop(g, :int_bus_map)[13]
&quot;24&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.leaf_busses" href="#BranchFlowModel.leaf_busses"><code>BranchFlowModel.leaf_busses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leaf_busses(p::Inputs)</code></pre><p>returns <code>Vector{String}</code> containing all of the leaf busses in <code>p.busses</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.init_inputs!" href="#BranchFlowModel.init_inputs!"><code>BranchFlowModel.init_inputs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_inputs!(ps::Vector{Inputs{SinglePhase}}; init_vs::Dict = Dict())</code></pre><p>Set the load on the upstream leaf noades equal to the sum of all the loads in the downstream inputs. It is important that the order of <code>ps</code> is from leaf branches to trunk branches so that the sums of loads take into account all downstream sub-trees.</p><p>if <code>init_vs</code> is provided, the <code>p.v0</code> is set for the <code>Input</code> with its <code>p.substation_bus</code> equal      to the key in <code>init_vs</code></p><pre><code class="language-julia hljs">init_vs = Dict(
    &quot;sub_bus_1&quot; =&gt; 0.98
)

for p in ps
    if p.substation_bus in keys(init_vs)
        p.v0 = init_vs[p.substation_bus]
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L48-L68">source</a></section><section><div><pre><code class="nohighlight hljs">init_inputs!(mg::MetaDiGraph; init_vs::Dict = Dict())</code></pre><p>Use the <code>:load_sum_order</code> in <code>mg</code> to <code>init_inputs!</code> in the correct order, i.e. set the loads at the leaf - substation connections as sums of all the loads (and the voltages at substations)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.set_inputs!" href="#BranchFlowModel.set_inputs!"><code>BranchFlowModel.set_inputs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_inputs!(mg::MetaDiGraph; α::Float64=0.0)</code></pre><p>Set the shared values in each subgraph / vertex of mg:</p><ol><li>set the current vertex&#39;s v0 to its inneighbor&#39;s voltage</li><li>set the current vertex P/Qload to the outneighbors&#39; substation_bus loads</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.split_at_busses" href="#BranchFlowModel.split_at_busses"><code>BranchFlowModel.split_at_busses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_at_busses(p::Inputs{SinglePhase}, at_busses::Vector{String})</code></pre><p>Split <code>Inputs</code> using the <code>at_busses</code></p><p>returns MetaDiGraph with vertex properties <code>:p</code> containing <code>Input</code> for the sub-graphs. For example <code>mg[2, :p]</code> is the <code>Input</code> at the second vertex of the graph created by splitting  the network via the <code>at_busses</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L186-L194">source</a></section><section><div><pre><code class="nohighlight hljs">split_at_busses(p::Inputs{SinglePhase}, at_busses::Vector{String}, with_busses::Vector{Vector{String}})</code></pre><p>Split up <code>p</code> using the <code>at_busses</code> as each new <code>substation_bus</code> and containing the corresponding <code>with_busses</code>. The <code>at_busses</code> and <code>with_busses</code> can be determined using <code>splitting_busses</code>.</p><p>NOTE: this variation of splt<em>at</em>busses allows for more than two splits at the same bus; whereas the other implementation of split<em>at</em>busses only splits the network into two parts for everything above and everything below a splitting bus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L243-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.get_diffs" href="#BranchFlowModel.get_diffs"><code>BranchFlowModel.get_diffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_diffs(mg::MetaDiGraph)</code></pre><p>Uses the JuMP Models stored in mg[:m] to calculate the difference between Pj, Qj, and |v| at every leaf/substation connection. </p><p>returns three <code>Float64[]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L315-L322">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>all_outneighbors</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>all_inneighbors</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="CommonOPF.busses_from_deepest_to_source" href="#CommonOPF.busses_from_deepest_to_source"><code>CommonOPF.busses_from_deepest_to_source</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">busses_from_deepest_to_source(g::MetaDiGraph, source::String)</code></pre><p>return the busses and their integer depths in order from deepest from shallowest</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>vertices_from_deepest_to_source</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.splitting_busses" href="#BranchFlowModel.splitting_busses"><code>BranchFlowModel.splitting_busses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splitting_busses(p::Inputs{SinglePhase}, source::String; threshold::Int64=10)</code></pre><p>Determine the busses to split a tree graph on by searching upward from the deepest leafs first and gathering the nearest busses until threshold is met for each subgraph.</p><p>Returns a <code>Vector{String}</code> for the bus names and <code>Vector{Vector{String}}</code> for the corresponding busses within each sub-graph.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not enough to have only the splitting busses to obey the <code>max_busses</code> limit because one must also know which sub branches to take from each splitting bus. In other words, we also need all the busses within each subgraph to split properly. For example, if a splitting bus has two sub branches then obeying the max_busses limit can require only including one sub branch out of the splitting bus. To know which branch to take we can use the other busses in the sub graph.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L357-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.connect_subgraphs_at_busses" href="#BranchFlowModel.connect_subgraphs_at_busses"><code>BranchFlowModel.connect_subgraphs_at_busses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">connect_subgraphs_at_busses(p::Inputs{SinglePhase}, at_busses::Vector{String}, subgraphs::Vector{Vector})</code></pre><p>The splitting_busses algorithm does not include over laps in subgraphs. But, we want overlaps at the splitting busses for solving the decomposed branch flow model. So here we add the overlapping splitting busses to each sub graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L419-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.split_inputs" href="#BranchFlowModel.split_inputs"><code>BranchFlowModel.split_inputs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_inputs(p::Inputs{SinglePhase}, bus::String, g::SimpleDiGraph)</code></pre><p>Split inputs into one graph for everything above <code>bus</code> and one graph for everything     below <code>bus</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/inputs.jl#L79-L84">source</a></section><section><div><pre><code class="nohighlight hljs">split_inputs(p::Inputs{SinglePhase}, bus::String, out_buses::Vector{String})</code></pre><p>Split <code>p</code> into <code>p_above</code> and <code>p_below</code> where <code>p_below</code> has only <code>out_buses</code> and <code>p_above</code> has <code>union( [bus], setdiff(p.busses, out_buses) )</code>.</p><p>Note that <code>out_buses</code> must contain <code>bus</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/inputs.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.build_metagraph" href="#BranchFlowModel.build_metagraph"><code>BranchFlowModel.build_metagraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_metagraph(p::Inputs{SinglePhase}, source::String; max_busses::Int64=10)</code></pre><p>return MetaDiGraph with <code>:p</code> property set for every vertex by splitting the <code>Inputs</code> via <code>splitting_busses</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L468-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.solve_metagraph!" href="#BranchFlowModel.solve_metagraph!"><code>BranchFlowModel.solve_metagraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_metagraph!(mg::MetaDiGraph, builder::Function, tol::T; α::T=0.5, verbose=false) where T &lt;: Real</code></pre><p>Given a MetaDiGraph and a JuMP Model <code>builder</code> method iteratively solve the models until the <code>tol</code> is  met for the differences provided by <code>BranchFlowModel.get_diffs</code>. </p><p>The <code>builder</code> must accept only one argument of type <code>BranchFlowModel.AbstractInputs</code> that returns  a <code>JuMP.AbstractModel</code>. Each model returned from the <code>builder</code> is stored as an <code>:m</code> property in  each vertex of <code>mg</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>tol</code> is compared to the maximum absolute value of all the p, q, and v differences.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L479-L491">source</a></section><section><div><pre><code class="nohighlight hljs">solve_metagraph!(mg::MetaDiGraph, builder::Function, tols::Vector{T}; α::T=0.5, verbose=false) where T &lt;: Real</code></pre><p>Given a MetaDiGraph and a JuMP Model <code>builder</code> method iteratively solve the models until the <code>tols</code> are  met for the differences provided by <code>BranchFlowModel.get_diffs</code>. </p><p>The <code>builder</code> must accept only one argument of type <code>BranchFlowModel.AbstractInputs</code> that returns  a <code>JuMP.AbstractModel</code>. Each model returned from the <code>builder</code> is stored as an <code>:m</code> property in  each vertex of <code>mg</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>tols</code> should have a length of three. The first value is compared to the maximum absolute difference in Pj, the second for Qj, and the third for |v|. All differences are calculated at the leaf/substation connections.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L524-L538">source</a></section><section><div><pre><code class="nohighlight hljs">solve_metagraph!(mg::MetaDiGraph, builder::Dict{Int64, Function}, tols::Vector{T}; α::T=0.5, verbose=false) where T &lt;: Real</code></pre><p>Given a MetaDiGraph and a JuMP Model <code>builder</code> method iteratively solve the models until the <code>tols</code> are  met for the differences provided by <code>BranchFlowModel.get_diffs</code>.  The <code>builder</code> dict is used to build each model for the corresponding vertex key.</p><p>Each function in the <code>builder</code> dict must accept only one argument of type <code>BranchFlowModel.AbstractInputs</code> that returns  a <code>JuMP.AbstractModel</code>. Each model returned from the builder function is stored as an <code>:m</code> property in  each vertex of <code>mg</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>tols</code> should have a length of three. The first value is compared to the maximum absolute difference in Pj, the second for Qj, and the third for |v|. All differences are calculated at the leaf/substation connections.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/decomposition.jl#L571-L586">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>metagraph_voltages</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.check_unique_solution_conditions" href="#BranchFlowModel.check_unique_solution_conditions"><code>BranchFlowModel.check_unique_solution_conditions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_unique_solution_conditions(p::Inputs)</code></pre><p>report the maximum per-unit immpedance and load values. See Chiang and Baran 2013: A load flow solution with feasible voltage magnitude always exists and is unique when</p><ol><li>V0 ≈ 1</li><li>loss values &lt; 1</li><li>rpu, xpu &lt;&lt; 1</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L296-L306">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>check_statuses</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.reg_busses" href="#BranchFlowModel.reg_busses"><code>BranchFlowModel.reg_busses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reg_busses(p::Inputs)</code></pre><p>All of the regulated busses, i.e. the second bus in the regulated edges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L326-L330">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>turn_ratio</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>vreg</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_vreg</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.combine_parallel_lines!" href="#BranchFlowModel.combine_parallel_lines!"><code>BranchFlowModel.combine_parallel_lines!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine_parallel_lines!(p::Inputs)</code></pre><p>Combine any parallel single phase lines without loads on intermediate busses into one multiphase line</p><p>TODO this can probably be used for LinDistFlow too but then have to move rij and other     utils.jl stuff to CommonOPF.jl (and distinguish between multiphase LinDistFlow and      BranchFlowModel Inputs)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L134-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.remove_bus!" href="#BranchFlowModel.remove_bus!"><code>BranchFlowModel.remove_bus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_bus!(j::String, p::Inputs{SinglePhase})</code></pre><p>Remove bus <code>j</code> in the line i-&gt;j-&gt;k from the model by making an equivalent line from busses i-&gt;k</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L57-L61">source</a></section><section><div><pre><code class="nohighlight hljs">remove_bus!(j::String, p::Inputs{MultiPhase})</code></pre><p>Remove bus <code>j</code> in the line i-&gt;j-&gt;k from the model by making an equivalent line from busses i-&gt;k</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/utils.jl#L95-L99">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>paths_between</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BranchFlowModel.Results-Tuple{AbstractModel, Inputs{SinglePhase}}" href="#BranchFlowModel.Results-Tuple{AbstractModel, Inputs{SinglePhase}}"><code>BranchFlowModel.Results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Results(m::AbstractModel, p::Inputs{SinglePhase})</code></pre><p>return a <code>Results</code> struct with fieldnames:</p><pre><code class="nohighlight hljs">voltage_magnitudes
real_power_injections
reactive_power_injections
current_magnitudes
real_sending_end_powers
reactive_sending_end_powers</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NLaws/BranchFlowModel.jl/blob/3387702f05d0c05bd6dd22659b7b7a62f53161ff/src/results.jl#L16-L28">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« User Documentation</a><a class="docs-footer-nextpage" href="../math/">Math »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 15:22">Tuesday 18 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
