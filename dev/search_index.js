var documenterSearchIndex = {"docs":
[{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"BranchFlowModel.jl documents each model's variables using the CommonOPF.VariableInfo, stored in the CommonOPF.Network.var_info dict. The keys(var_info) are symbols that correspond with the symbols stored in the JuMP.Model.obj_dict. If m is the JuMP.Model provided by the user, then the variables can be accessed via m[:a_var_symbol]. Similarly, the VariableInfo is accessed via network.var_info[:a_var_symbol].","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"After a model has been solved using JuMP.optimize! variable values can be extracted with JuMP.value. For more see Getting started with JuMP.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Variables are stored in dictionaries. The order of the keys in the dictionaries is standardized in CommonOPF variable containers.","category":"page"},{"location":"constraints/#Accessing-and-Modifying-Constraints","page":"Constraints","title":"Accessing and Modifying Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Let the JuMP.Model provided by the user be called m.  The constraints are stored in the model dict as anonymous constraints with symbol keys. The constraint keys are documented in the Network.constraint_info when build_bfm! is called. ","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"using BranchFlowModel\nusing CommonOPF\nusing JuMP\nusing ECOS\n\n\nnet = Network_Papavasiliou_2018()\n\nm = JuMP.Model(ECOS.Optimizer) \n\n# modify the power balance constraints at bus 11, adding real and reactive power injection variables\nb = \"11\"\n@variable(m, 0.4 >= pgen11 >= 0)\n@variable(m, 0.4 >= qgen11 >= 0)\n\nJuMP.delete.(m, m[:power_balance_constraints][b][:real])\n\nm[:power_balance_constraints][b][:real] = @constraint(m, \n    sum( m[:pij][(i,b)][1] for i in i_to_j(b, net) )\n    - sum( m[:lij][(i,b)][1] * rij(i,b,net) for i in i_to_j(b, net) ) \n    + pgen11 - net[b][:Load].kws1[1] == 0\n)\n\nJuMP.delete.(m, m[:power_balance_constraints][b][:reactive])\nm[:power_balance_constraints][b][:reactive] = @constraint(m, \n    sum( m[:pij][(i,b)][1] for i in i_to_j(b, net) )\n    - sum( m[:lij][(i,b)][1] * rij(i,b,net) for i in i_to_j(b, net) ) \n    + qgen11 - net[b][:Load].kvars1[1] == 0\n)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See the JuMP documentation for more on deleting constraints.","category":"page"},{"location":"multi_phase_models/#Multiphase-Models","page":"Multiphase Models","title":"Multiphase Models","text":"","category":"section"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"BranchFlowModel.jl provides methods to build many different variations of the Branch Flow Model, including single phase and multiphase models. Each of the model types supported are documented below.","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"Pages = [\"multi_phase_models.md\"]\nDepth = 2","category":"page"},{"location":"multi_phase_models/#Unrelaxed-models","page":"Multiphase Models","title":"Unrelaxed models","text":"","category":"section"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The Unrelaxed multiphase model is built by passing a JuMP.Model, Network{MultiPhase}, and the Unrelaxed type to build_bfm!.","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"net = CommonOPF.Network_IEEE13()\nm = JuMP.Model()\n\nbuild_bfm!(m, net, Unrelaxed)\nprintln(\"Variable information:\")\nCommonOPF.print_var_info(net)\nprintln(\"Constraint information:\")\nCommonOPF.print_constraint_info(net)","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The `build_bfm! method uses:","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"BranchFlowModel.add_bfm_variables\nBranchFlowModel.constrain_bfm_nlp\nBranchFlowModel.constrain_power_balance","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The math underlying the model is as follows:","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"beginaligned\n    boldsymbol S_ij = boldsymbol v_i^Phi_ij boldsymbol i_ij^H\n    quad forall (i j) in mathcalE\n    \n    boldsymbol v_i^Phi_ij - boldsymbol v_j = boldsymbol Z_ij boldsymbol i_ij\n    quad forall (i j) in mathcalE\n    \n    sum_i  i rightarrow j  textdiag( boldsymbol S_ij - boldsymbol Z_ij left boldsymbol i_ij boldsymbol i_ij^H right) \n    + boldsymbol s_j \n    = sum_k  j rightarrow k textdiag( boldsymbol S_jk )^Phi_j\n    quad forall j in mathcalN\nendaligned","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"For the nomenclature see TODO.","category":"page"},{"location":"multi_phase_models/#Semidefinite-models","page":"Multiphase Models","title":"Semidefinite models","text":"","category":"section"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The Semidefinite multiphase model is built by passing a JuMP.Model, Network{MultiPhase}, and the Semidefinite type to build_bfm!.","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"net = CommonOPF.Network_IEEE13()\nm = JuMP.Model()\n\nbuild_bfm!(m, net, Semidefinite)\nprintln(\"Variable information:\")\nCommonOPF.print_var_info(net)\nprintln(\"Constraint information:\")\nCommonOPF.print_constraint_info(net)","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The `build_bfm! method uses:","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"BranchFlowModel.add_sdp_variables\nBranchFlowModel.constrain_KVL\nBranchFlowModel.constrain_power_balance","category":"page"},{"location":"multi_phase_models/#Linear-models","page":"Multiphase Models","title":"Linear models","text":"","category":"section"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The Linear multiphase model is built by passing a JuMP.Model, Network{MultiPhase}, and the Linear type to build_bfm!.","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"net = CommonOPF.Network_IEEE13()\nm = JuMP.Model()\n\nbuild_bfm!(m, net, Linear)\nprintln(\"Variable information:\")\nCommonOPF.print_var_info(net)\nprintln(\"Constraint information:\")\nCommonOPF.print_constraint_info(net)","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The `build_bfm! method uses:","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"BranchFlowModel.add_linear_variables\nBranchFlowModel.constrain_linear_power_balance\nBranchFlowModel.constrain_KVL_linear","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"The math underlying the model is as follows (from Arnold et al.):","category":"page"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"beginaligned\nP_ijphi + p_jphi = sum_kjrightarrow k P_jkphi  forall j in mathcalN^+ forall phi in 123 \nQ_ijphi + q_jphi = sum_kjrightarrow k Q_jkphi  forall j in mathcalN^+ forall phi in 123 \nboldsymbolw_j = boldsymbolw_i + boldsymbolM_Pij boldsymbolP_ij + boldsymbolM_Qij boldsymbolQ_ij \n(boldsymbolv_jmin)^2 le boldsymbolw_j le (boldsymbolv_jmax)^2  forall j in mathcalN^+ \nboldsymbolM_Pij = beginbmatrix\n-2r_11                 r_12-sqrt3x_12  r_13+sqrt3x_13 \n  r_21+sqrt3x_21  -2r_22  r_23-sqrt3x_23 \n  r_31-sqrt3x_31  r_32+sqrt3x_32  -2r_33\nendbmatrix \nboldsymbolM_Qij = beginbmatrix\n-2x_11                   x_12+sqrt3r_12    x_13-sqrt3r_13 \n  x_21-sqrt3r_21   -2x_22                   x_23+sqrt3r_23 \n  x_31+sqrt3r_31    x_32-sqrt3r_32  -2x_33\nendbmatrix \nendaligned","category":"page"},{"location":"multi_phase_models/#References","page":"Multiphase Models","title":"References","text":"","category":"section"},{"location":"multi_phase_models/#Arnold-et-al.","page":"Multiphase Models","title":"Arnold et al.","text":"","category":"section"},{"location":"multi_phase_models/","page":"Multiphase Models","title":"Multiphase Models","text":"Arnold, Daniel B., et al. \"Optimal dispatch of reactive power for voltage regulation and balancing in unbalanced distribution systems.\" 2016 IEEE Power and Energy Society General Meeting (PESGM). IEEE, 2016.","category":"page"},{"location":"methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Some various methods used in BranchFlowModel.jl:","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Pages = [\"methods.md\"]\nDepth = 3","category":"page"},{"location":"methods/#Model-builders","page":"Methods","title":"Model builders","text":"","category":"section"},{"location":"methods/#BranchFlowModel.build_bfm!","page":"Methods","title":"BranchFlowModel.build_bfm!","text":"build_bfm!(m::JuMP.AbstractModel, net::Network{SinglePhase}, mtype::ModelType=AngleRelaxation)\n\nTop-level single phase builder that dispatches the ModelType enum\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{SinglePhase}, ::Val{AngleRelaxation})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_linear_variables(m, net)\nadd_vsqrd_variables(m, net)\nadd_isqrd_variables(m, net)\nconstrain_power_balance_with_isqrd_losses(m, net)\nconstrain_substation_voltage(m, net)\nconstrain_KVL(m, net)\nconstrain_bilinear(m, net)\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{SinglePhase}, ::Val{SOC})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_linear_variables(m, net)\nadd_vsqrd_variables(m, net)\nadd_isqrd_variables(m, net)\nconstrain_power_balance_with_isqrd_losses(m, net)\nconstrain_substation_voltage(m, net)\nconstrain_KVL(m, net)\nconstrain_cone(m, net)\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{SinglePhase}, ::Val{Linear})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_linear_variables(m, net)\nadd_vsqrd_variables(m, net)\nadd_isqrd_variables(m, net)\nconstrain_power_balance_with_isqrd_losses(m, net)\nconstrain_substation_voltage(m, net)\nconstrain_KVL(m, net)\nconstrain_cone(m, net)\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{MultiPhase}, mtype::ModelType=Unrelaxed)\n\nTop-level multiphase builder that dispatches the ModelType enum\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{MultiPhase}, ::Val{Unrelaxed})\n\nAdd variables and constraints to m using the values in net to make an unrelaxed branch flow model. Calls the following functions:\n\nadd_bfm_variables\nconstrain_bfm_nlp\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{MultiPhase}, ::Val{Semidefinite})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_sdp_variables\nconstrain_power_balance\nconstrain_KVL\n\n\n\n\n\nbuild_bfm!(m::JuMP.AbstractModel, net::Network{MultiPhase}, ::Val{Linear})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_linear_variables\nconstrain_linear_power_balance\nconstrain_KVL_linear\n\n\n\n\n\n","category":"function"},{"location":"methods/#Variable-builders","page":"Methods","title":"Variable builders","text":"","category":"section"},{"location":"methods/#BranchFlowModel.add_bfm_variables","page":"Methods","title":"BranchFlowModel.add_bfm_variables","text":"add_bfm_variables(m, net::Network{MultiPhase})\n\nDefine complex variables for:\n\n:v bus voltage vectors\n:i branch current vectors\n:Sij branch power flow matrices\n:sj bus net power injection vectors\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.add_sdp_variables","page":"Methods","title":"BranchFlowModel.add_sdp_variables","text":"add_sdp_variables(m, net::Network{MultiPhase})\n\nCreate complex variables:\n\nm[:w] are 3x3 Hermitian matrices of voltage squared (V*V^T)\nm[:l] are 3x3 Hermitian matrices of current squared (I*I^T)\nm[:sj] are 3x1 matrices of net power injections (at bus j)\nm[:Sij] are 3x3 Complex matrices of line flow powers (from i to j)\n\nAlso:\n\nm[:H] are 3x3 Hermitian matrices of the positive semi-definite constraints\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.add_linear_variables","page":"Methods","title":"BranchFlowModel.add_linear_variables","text":"add_linear_variables(m, net::Network{SinglePhase})\n\nAdd variables for the single-phase, linear model:\n\npij and qij for all edges(net)\np0 and q0 slack bus power\n\n\n\n\n\nadd_linear_variables(m, net::Network{MultiPhase})\n\nDefine real phase-vector variables for:\n\n:vsqrd bus voltage magnitude squared\n:pij, :qij branch power flows\n:p, :q for the slack bus net power injection\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.add_vsqrd_variables","page":"Methods","title":"BranchFlowModel.add_vsqrd_variables","text":"add_vsqrd_variables(m, net::Network{SinglePhase})\n\nAdd m[:vsqrd] time vectdor variables. Applies upper/lower bounds if the net.bounds.v_lower/upper_mag are not missing.\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.add_isqrd_variables","page":"Methods","title":"BranchFlowModel.add_isqrd_variables","text":"add_isqrd_variables(m, net::Network{SinglePhase})\n\nAdd m[:lij] time vector variables with a lower bound of zero.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Constraint-builders","page":"Methods","title":"Constraint builders","text":"","category":"section"},{"location":"methods/#BranchFlowModel.constrain_power_balance","page":"Methods","title":"BranchFlowModel.constrain_power_balance","text":"function constrain_power_balance(m, net::Network{MultiPhase})\n\nSij in - losses == sum of line flows out + net injection NOTE: using sum over pij for future expansion to mesh grids i -> j -> k\n\nAll of the power balance constraints are stored in m[:power_balance_constraints] with the bus name (string) as the first index. For example m[:power_balance_constraints][\"busname\"] will give the constrain container from JuMP for all time steps.\n\nsum_i  i rightarrow j  textdiag(      boldsymbol S_ij - boldsymbol Z_ij left boldsymbol i_ij boldsymbol i_ij^H right)      + boldsymbol s_j      = sum_k  j rightarrow k textdiag( boldsymbol S_jk )^Phi_j     quad forall j in mathcalN\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_KVL","page":"Methods","title":"BranchFlowModel.constrain_KVL","text":"constrain_KVL(m, net::Network{SinglePhase})\n\nw_j = w_i - 2 (p_ij r_ij + q_ij x_ij) + (r_ij^2 + x_ij^2) ell_ij \nquad forall (i j) in mathcalE\n\n\n\n\n\nconstrain_KVL(m, net::Network{MultiPhase})\n\nAdd the voltage drop definitions between busses using the sending end powers and the current squared variables. This is the angle-relaxation form used in the semi-definite program.\n\nNOTE regulators are also hacked in here, setting the voltage to vreg_pu or using the turn_ratio as appropriate.\n\nw_j = w_i - S_ij Z^star - Z S_ij^star + Z L_ij Z^star\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_bfm_nlp","page":"Methods","title":"BranchFlowModel.constrain_bfm_nlp","text":"constrain_bfm_nlp(m, net::Network{MultiPhase})\n\nAdd the unrelaxed branch flow constraints. Also calls constrain_power_balance.\n\nboldsymbol S_ij = boldsymbol v_i^Phi_ij boldsymbol i_ij^H     quad forall (i j) in mathcalE\n\nboldsymbol v_i^Phi_ij - boldsymbol v_j = boldsymbol Z_ij boldsymbol i_ij     quad forall (i j) in mathcalE\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_linear_power_balance","page":"Methods","title":"BranchFlowModel.constrain_linear_power_balance","text":"constrain_linear_power_balance(m, net::Network{MultiPhase})\n\np_ijphi + p_jphi = sumkjrightarrow k p_jkphi  quad forall j in mathcalN forall phi in 123\n\nq_ijphi + q_jphi = sumkjrightarrow k q_jkphi  quad forall j in mathcalN  forall phi in 123\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_KVL_linear","page":"Methods","title":"BranchFlowModel.constrain_KVL_linear","text":"constrain_KVL_linear(m, net::Network{SinglePhase})\n\nw_j = w_i - 2 r_ij P_ij - 2 x_ij Q_ij quad forall j in mathcalN\n\n\n\n\n\nconstrain_KVL_linear(m, net::Network{MultiPhase})\n\nboldsymbolw_j = boldsymbolw_i + boldsymbolM_Pij boldsymbolP_ij      + boldsymbolM_Qij boldsymbolQ_ij\n\nSee MPij and MQij for their definitions.\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_power_balance_with_isqrd_losses","page":"Methods","title":"BranchFlowModel.constrain_power_balance_with_isqrd_losses","text":"function constrain_power_balance_with_isqrd_losses(m, net::Network)\n\nDefine the m[:powerbalanceconstraints][bus] ∀ bus ∈ busses(net) as a Dict of constraints. The keys are \"p\" and \"q\" for real and reactive power balance respectively. The values are the JuMP constraints.\n\n∑ pij in - losses + net injection - ∑ Pjk out = 0\n\nThe net injection are user defined loads. If one wishes to make the net injection a decision variable then delete the constraint and redefine the constraint with your decision variable.\n\nNOTE: using sum over pij for future expansion to mesh grids and the convention: i -> j -> k\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_bilinear","page":"Methods","title":"BranchFlowModel.constrain_bilinear","text":"constrain_bilinear(m, net::Network{SinglePhase})\n\nw_i ell_ij = p_ij^2 + q_ij^2 quad forall (i j) in mathcalE\n\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_substation_voltage","page":"Methods","title":"BranchFlowModel.constrain_substation_voltage","text":"constrain_substation_voltage(m, net::Network{SinglePhase})\n\nConstrain m[:vsqrd][net.substation_bus] to net.v0^2 (or net.v0[t]^2 if net.v0 is not Real)\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_cone","page":"Methods","title":"BranchFlowModel.constrain_cone","text":"constrain_cone(m, net::Network{SinglePhase})\n\nell_ij geq fracp_ij^2 + q_ij^2w_i quad forall (i j) in mathcalE\n\n\n\n\n\n","category":"function"},{"location":"methods/#Other","page":"Methods","title":"Other","text":"","category":"section"},{"location":"methods/#BranchFlowModel.MPij","page":"Methods","title":"BranchFlowModel.MPij","text":"MPij(i::String, j::String, net::Network{MultiPhase})\n\nReal power coefficients for 3 phase voltage drop from node i to j\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.MQij","page":"Methods","title":"BranchFlowModel.MQij","text":"MQij(i::String, j::String, net::Network{MultiPhase})\n\nReactive power coefficients for 3 phase voltage drop from node i to j\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.check_rank_one","page":"Methods","title":"BranchFlowModel.check_rank_one","text":"check_rank_one(m::JuMP.AbstractModel, net::Network, tol=1e-3)\n\nCheck the rank of the m[:H] matrices from the PSD cone constraints. Warnings express any values with rank greater than one.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.reduce_tree!","page":"Methods","title":"CommonOPF.reduce_tree!","text":"reduce_tree!(net::Network{SinglePhase})\n\ncombine any line sets with intermediate busses that have indegree == outdegree == 1 and is not a load bus into a single line\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.trim_tree!","page":"Methods","title":"CommonOPF.trim_tree!","text":"trim_tree!(net::Network)\n\nTrim any branches that have empty busses, i.e. remove the branches that have no loads or DER.\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.set_inputs!","page":"Methods","title":"BranchFlowModel.set_inputs!","text":"set_inputs!(mg::MetaGraphsNext.MetaGraph; α::Float64=0.0)\n\nSet the shared values in each subgraph / vertex of mg:\n\nset the current vertex's v0 to its inneighbor's voltage\nset the current vertex P/Qload to the outneighbors' substation_bus loads\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.get_diffs","page":"Methods","title":"BranchFlowModel.get_diffs","text":"get_diffs(mg::MetaGraphsNext.MetaGraph)\n\nUses the JuMP Models stored in mg.graph_data[:models] to calculate the difference between power injections/loads, and |v| at every leaf/substation connection. \n\nreturns three Float64[]\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.solve_metagraph!","page":"Methods","title":"BranchFlowModel.solve_metagraph!","text":"solve_metagraph!(mg::MetaGraphsNext.MetaGraph, builder::Function, tol::T; α::T=0.5, verbose=false) where T <: Real\n\nGiven a MetaGraphsNext.MetaGraph and a JuMP Model builder method iteratively solve the models until the tol is met for the differences provided by BranchFlowModel.get_diffs. \n\nThe builder must accept only one argument of type CommonOPF.AbstractNetwork that returns  a JuMP.AbstractModel. Each model returned from the builder is stored as an :m property in  each vertex of mg.\n\nnote: Note\ntol is compared to the maximum absolute value of all the p, q, and v differences.\n\n\n\n\n\nsolve_metagraph!(mg::MetaGraphsNext.MetaGraph, builder::Function, tols::Vector{T}; α::T=0.5, verbose=false) where T <: Real\n\nGiven a MetaGraphsNext.MetaGraph and a JuMP Model builder method iteratively solve the models until the tols are met for the differences provided by BranchFlowModel.get_diffs. \n\nThe builder must accept only one argument of type CommonOPF.AbstractNetwork that returns  a JuMP.AbstractModel. Each model returned from the builder is stored as an :m property in  each vertex of mg.\n\nnote: Note\nThe tols should have a length of three. The first value is compared to the maximum absolute difference in real power, the second for reactive power, and the third for |v|. All differences are calculated at the leaf/substation connections.\n\n\n\n\n\nsolve_metagraph!(mg::MetaGraphsNext.MetaGraph, builder::Dict{Int64, Function}, tols::Vector{T}; α::T=0.5, verbose=false) where T <: Real\n\nGiven a MetaGraphsNext.MetaGraph and a JuMP Model builder method iteratively solve the models until the tols are met for the differences provided by BranchFlowModel.get_diffs. The builder dict is used to build each model for the corresponding vertex key.\n\nEach function in the builder dict must accept only one argument of type CommonOPF.AbstractNetwork that returns a JuMP.AbstractModel. Each model returned from the builder function is stored as an :m property in each vertex of mg.\n\nnote: Note\nThe tols should have a length of three. The first value is compared to the maximum absolute difference in real power, the second for reactive power, and the third for |v|. All differences are calculated at the leaf/substation connections.\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.check_statuses","page":"Methods","title":"BranchFlowModel.check_statuses","text":"check_statuses(mg::MetaGraphsNext.MetaGraph)\n\nWarn if any sub-model has a JuMP.termination_status not in [MOI.OPTIMAL, MOI.ALMOST_OPTIMAL, MOI.LOCALLY_SOLVED]\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.remove_bus!","page":"Methods","title":"CommonOPF.remove_bus!","text":"remove_bus!(j::String, net::Network{SinglePhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\nremove_bus!(j::String, net::Network{MultiPhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k. We assume the conductors from i->j and j->k have impedance matrices.\n\n\n\n\n\n","category":"function"},{"location":"#BranchFlowModel.jl","page":"User Documentation","title":"BranchFlowModel.jl","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"BranchFlowModel builds the branch flow constraints using JuMP. The intent of this package is to allow users to build mathematical programs that include BranchFlowModel constraints. No objective is added to the JuMP model in this package and so solving any problem defined by the constraints built by BranchFlowModel.jl is a feasibility problem. Dictionaries of constraints are provided so that one can delete and/or modify the base constraints to fit their problem.","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"warning: Warning\nThis package is under development. Contributions are welcome via fork and pull request.","category":"page"},{"location":"#Inputs","page":"User Documentation","title":"Inputs","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Inputs are defined using CommonOPF.Network structs. ","category":"page"},{"location":"#Building-a-Model","page":"User Documentation","title":"Building a Model","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Building a BranchFlowModel requires three things:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"a JuMP Model,\na CommonOPF.Network, and\nthe type of model to be built, i.e. one of the BranchFlowModel.ModelType","category":"page"},{"location":"#BranchFlowModel.ModelType","page":"User Documentation","title":"BranchFlowModel.ModelType","text":"ModelType\n\nAn enum with values:\n\nUnrelaxed\nAngleRelaxation\nSemidefinite\nSOC  \nLinear\n\nnote: Note\nJuMP exports SecondOrderCone so we abbreviate it as SOC.\n\n\n\n\n\n","category":"type"},{"location":"","page":"User Documentation","title":"User Documentation","text":"To build a model see build_bfm!","category":"page"},{"location":"single_phase_models/#Single-Phase-Models","page":"Single Phase Models","title":"Single Phase Models","text":"","category":"section"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"BranchFlowModel.jl provides methods to build many different variations of the Branch Flow Model, including single phase and multiphase models. Each of the model types supported are documented below.","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"Pages = [\"single_phase_models.md\"]\nDepth = 2","category":"page"},{"location":"single_phase_models/#AngleRelaxation","page":"Single Phase Models","title":"AngleRelaxation","text":"","category":"section"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The AngleRelaxation single phase model is built by passing a JuMP.Model, Network{SinglePhase}, and the AngleRelaxation type to build_bfm!.","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"net = CommonOPF.Network_IEEE13_SinglePhase()\nm = JuMP.Model()\n\nbuild_bfm!(m, net, AngleRelaxation)\nprintln(\"Variable information:\")\nCommonOPF.print_var_info(net)\nprintln(\"Constraint information:\")\nCommonOPF.print_constraint_info(net)","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The `build_bfm! method uses:","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"BranchFlowModel.add_linear_variables\nBranchFlowModel.add_vsqrd_variables\nBranchFlowModel.add_isqrd_variables\nBranchFlowModel.constrain_power_balance_with_isqrd_losses\nBranchFlowModel.constrain_KVL\nBranchFlowModel.constrain_bilinear","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The math underlying the model is as follows [Farivar and Low]:","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"beginaligned\n    sum_i  i rightarrow j ( p_ij - r_ij ell_ij ) + p_j \n    = sum_k  j rightarrow k p_jk \n    quad forall j in mathcalN\n    \n    sum_i  i rightarrow j ( q_ij - x_ij ell_ij ) + q_j \n    = sum_k  j rightarrow k q_jk \n    quad forall j in mathcalN\n    \n    w_j = w_i - 2 (p_ij r_ij + q_ij x_ij) + (r_ij^2 + x_ij^2) ell_ij \n    quad forall (i j) in mathcalE\n    \n     ell_ij w_i = p_ij^2 + q_ij^2 quad forall (i j) in mathcalE\nendaligned","category":"page"},{"location":"single_phase_models/#SOC-models","page":"Single Phase Models","title":"SOC models","text":"","category":"section"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The SOC (second order cone) single phase model is built by passing a JuMP.Model, Network{SinglePhase}, and the SOC type to build_bfm!.","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"net = CommonOPF.Network_IEEE13_SinglePhase()\nm = JuMP.Model()\n\nbuild_bfm!(m, net, SOC)\nprintln(\"Variable information:\")\nCommonOPF.print_var_info(net)\nprintln(\"Constraint information:\")\nCommonOPF.print_constraint_info(net)","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The `build_bfm! method uses:","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"BranchFlowModel.add_linear_variables(m, net)\nBranchFlowModel.add_vsqrd_variables(m, net)\nBranchFlowModel.add_isqrd_variables(m, net)\nBranchFlowModel.constrain_power_balance_with_isqrd_losses(m, net)\nBranchFlowModel.constrain_substation_voltage(m, net)\nBranchFlowModel.constrain_KVL(m, net)\nBranchFlowModel.constrain_cone(m, net)","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The math underlying the model is as follows [Farivar and Low]:","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"beginaligned\n    sum_i  i rightarrow j ( p_ij - r_ij ell_ij ) + p_j \n    = sum_k  j rightarrow k p_jk \n    quad forall j in mathcalN\n    \n    sum_i  i rightarrow j ( q_ij - x_ij ell_ij ) + q_j \n    = sum_k  j rightarrow k q_jk \n    quad forall j in mathcalN\n    \n    w_j = w_i - 2 (p_ij r_ij + q_ij x_ij) + (r_ij^2 + x_ij^2) ell_ij \n    quad forall (i j) in mathcalE\n    \n     ell_ij geq fracp_ij^2 + q_ij^2w_i quad forall (i j) in mathcalE\nendaligned","category":"page"},{"location":"single_phase_models/#Linear-models","page":"Single Phase Models","title":"Linear models","text":"","category":"section"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The single phase \"LinDistFlow\" model from [Baran and Wu].  The Linear single phase model is built by passing a JuMP.Model, Network{SinglePhase}, and the Linear type to build_bfm!.","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"net = CommonOPF.Network_IEEE13_SinglePhase()\nm = JuMP.Model()\n\nbuild_bfm!(m, net, Linear)\nprintln(\"Variable information:\")\nCommonOPF.print_var_info(net)\nprintln(\"Constraint information:\")\nCommonOPF.print_constraint_info(net)","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"The math underlying the model is as follows:","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"Notation:","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"P_ij real power flow from node i to node j\np_j real power injection on node j\nmathcalN^+ set of all nodes in network except the source\nw_j voltage magnitude squared on node j","category":"page"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"beginaligned\nP_ij + p_j = sum_kjrightarrow k P_jk  forall j in mathcalN^+ \nQ_ij + q_j = sum_kjrightarrow k Q_jk  forall j in mathcalN^+ \nw_j = w_i - 2 r_ij P_ij - 2 x_ij Q_ij  forall j in mathcalN^+ \n(v_jmin)^2 le w_j le (v_jmax)^2  forall j in mathcalN^+ \nendaligned","category":"page"},{"location":"single_phase_models/#References","page":"Single Phase Models","title":"References","text":"","category":"section"},{"location":"single_phase_models/#[Baran-and-Wu]","page":"Single Phase Models","title":"[Baran and Wu]","text":"","category":"section"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"Baran, Mesut E., and Felix F. Wu. \"Optimal capacitor placement on radial distribution systems.\" IEEE Transactions on power Delivery 4.1 (1989): 725-734. Chicago\t","category":"page"},{"location":"single_phase_models/#[Farivar-and-Low]","page":"Single Phase Models","title":"[Farivar and Low]","text":"","category":"section"},{"location":"single_phase_models/","page":"Single Phase Models","title":"Single Phase Models","text":"Farivar, Masoud, and Steven H. Low. \"Branch flow model: Relaxations and convexification—Part I.\" IEEE Transactions on Power Systems 28.3 (2013): 2554-2564.","category":"page"}]
}
