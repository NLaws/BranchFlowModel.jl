var documenterSearchIndex = {"docs":
[{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"Methods to decompose and solve the SinglePhase Branch Flow Model are provided based on the work in  [2]. These methods are most advantageous when solving the non-linear (unrelaxed) power flow equations and are only valid(?) in radial networks.","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"init_inputs!\nset_inputs!\nget_diffs\nsplit_inputs","category":"page"},{"location":"decomposition/#BranchFlowModel.set_inputs!","page":"Decomposition","title":"BranchFlowModel.set_inputs!","text":"set_inputs!(mg::MetaGraphsNext.MetaGraph; α::Float64=0.0)\n\nSet the shared values in each subgraph / vertex of mg:\n\nset the current vertex's v0 to its inneighbor's voltage\nset the current vertex P/Qload to the outneighbors' substation_bus loads\n\n\n\n\n\n","category":"function"},{"location":"decomposition/#BranchFlowModel.get_diffs","page":"Decomposition","title":"BranchFlowModel.get_diffs","text":"get_diffs(mg::MetaGraphsNext.MetaGraph)\n\nUses the JuMP Models stored in mg.graph_data[:models] to calculate the difference between power injections/loads, and |v| at every leaf/substation connection. \n\nreturns three Float64[]\n\n\n\n\n\n","category":"function"},{"location":"decomposition/#[2]","page":"Decomposition","title":"[2]","text":"","category":"section"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"Sadnan, Rabayet, and Anamika Dubey. \"Distributed optimization using reduced network equivalents for radial power distribution systems.\" IEEE Transactions on Power Systems 36.4 (2021): 3645-3656.","category":"page"},{"location":"methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Some various methods used in BranchFlowModel.jl:","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"warning: Warning\nThis list of exported methods may not be up to date and there are missing doc strings. Contributions are welcome via fork and pull request.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Inputs(::String, ::String)\nInputs(::AbstractVector{<:Tuple}, ::AbstractVector{<:AbstractString}, ::AbstractVector{<:Real}, ::AbstractVector{<:AbstractVector}, ::String)\nsinglephase38linesInputs\ndsstxt_to_sparse_array \ndss_files_to_dict\nbuild_model!(m::JuMP.AbstractModel, p::Inputs{BranchFlowModel.SinglePhase})\nbuild_model!(m::JuMP.AbstractModel, p::Inputs{BranchFlowModel.MultiPhase})\nadd_variables\nconstrain_power_balance\nconstrain_substation_voltage\nconstrain_KVL\nconstrain_bounds\ncheck_rank_one\nget_bus_values \nget_edge_values \ncheck_soc_inequalities\nget_load_bal_shadow_prices\ncurrent_values_by_time_edge\nline_flow_values_by_time_edge\nreduce_tree!\ntrim_tree!\nmake_graph\nleaf_busses\nset_inputs!\nget_diffs\nsolve_metagraph!\nmetagraph_voltages\ncheck_unique_solution_conditions\ncheck_statuses\nreg_busses\nturn_ratio\nvreg\nhas_vreg\nremove_bus!\npaths_between\nResults(m::JuMP.AbstractModel, p::Inputs{SinglePhase}; digits=8)","category":"page"},{"location":"methods/#CommonOPF.Inputs-Tuple{AbstractVector{<:Tuple}, AbstractVector{<:AbstractString}, AbstractVector{<:Real}, AbstractVector{<:AbstractVector}, String}","page":"Methods","title":"CommonOPF.Inputs","text":"Inputs(\n    edges::Array{Tuple}, \n    linecodes::Array{String}, \n    linelengths::Array{Float64}, \n    phases::Vector{Vector},\n    substation_bus::String;\n    Pload, \n    Qload, \n    Sbase=1, \n    Vbase=1, \n    Zdict, \n    v0, \n    v_lolim=0.95, \n    v_uplim=1.05,\n    Ntimesteps=1, \n    P_up_bound=1e4,\n    Q_up_bound=1e4,\n    P_lo_bound=-1e4,\n    Q_lo_bound=-1e4,\n    Isquared_up_bounds=Dict{String, Float64}(),\n    relaxed=true\n)\n\nLowest level Inputs constructor (the only one that returns the Inputs struct). \n\nnote: Note\nThe real and reactive loads provided are normalized using Sbase.\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.singlephase38linesInputs","page":"Methods","title":"CommonOPF.singlephase38linesInputs","text":"singlephase38linesInputs(;\n    Pload=Dict{String, AbstractArray{Real, 1}}(), \n    Qload=Dict{String, AbstractArray{Real, 1}}(), \n    T=24,\n    loadnodes = [\"3\", \"5\", \"36\", \"9\", \"10\", \"11\", \"12\", \"13\", \"15\", \"17\", \"18\", \"19\", \"22\", \"25\", \n                \"27\", \"28\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\"],\n    Sbase = 1e6,\n    Vbase = 12.5e3,\n    v0=1.0,\n    v_uplim = 1.05,\n    v_lolim = 0.95,\n)\n\nConvenience function for creating a single phase network with 38 lines and nodes.  Taken from: Andrianesis et al. 2019 \"Locational Marginal Value of Distributed Energy Resources as Non-Wires Alternatives\"\n\nNOTE that Inputs is a mutable struct (s.t. loads can be added later).\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.dsstxt_to_sparse_array","page":"Methods","title":"CommonOPF.dsstxt_to_sparse_array","text":"dsstxt_to_sparse_array(fp::String, first_data_row::Int = 5)\n\nconvert a SystemY.txt file from OpenDSS to a julia matrix. assumes that Y is symmetric.\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.add_variables","page":"Methods","title":"BranchFlowModel.add_variables","text":"add_variables(m, net::Network{MultiPhase})\n\nCreate complex variables:\n\nm[:w] are 3x3 Hermitian matrices of voltage squared (V*V^T)\nm[:l] are 3x3 Hermitian matrices of current squared (I*I^T)\nm[:Sj] are 3x1 matrices of net power injections (at bus j)\nm[:Sij] are 3x3 Complex matrices of line flow powers (from i to j)\n\nThe positive semi-definite constraints are also defined and stored as\n\nm[:H][t][j] where t is time step and j is the bus name.\n\nAll of the variable containers have typeof Dict{Int, Dict{String, AbstractVecOrMat}}`.\n\nThe first index is time step (integer)\nThe second index is bus or line (string)\nand finally a matrix or vector of complex variables\n\nSome examples of using variables:\n\n\nvalue.(m[:Sj][1][\"671\"])\n\nvalue(variable_by_name(m, \"real(Sj_1_671_1)\"))\n\nvalue.(m[:w][1][\"671\"])\n\nvalue.(m[:Sj][1][net.substation_bus]) \n\nfor b in real_load_busses(net)\n    println(b, \"  \", value.(m[:Sj][1][b]))\nend\n\nfix(variable_by_name(m, \"real(Sj_1_645_3)\"), 0.0, force=true)\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_power_balance","page":"Methods","title":"BranchFlowModel.constrain_power_balance","text":"function constrain_power_balance(m, net::Network)\n\nDefine the m[:loadbalcons][bus] ∀ bus ∈ busses(net) as a Dict of constraints. The keys are \"p\" and \"q\" for real and reactive power balance respectively. The values are the JuMP constraints.\n\n∑ Pij in - losses + net injection - ∑ Pjk out = 0\n\nThe net injection are user defined loads. If one wishes to make the net injection a decision variable then delete the constraint and redefine the constraint with your decision variable.\n\nNOTE: using sum over Pij for future expansion to mesh grids and the convention: i -> j -> k\n\n\n\n\n\nfunction constrain_power_balance(m, net::Network{MultiPhase})\n\nSij in - losses == sum of line flows out + net injection NOTE: using sum over Pij for future expansion to mesh grids i -> j -> k\n\nAll of the power balance constraints are stored in m[:loadbalcons] with the bus name (string) as the first index. For example m[:loadbalcons][\"busname\"] will give the constrain container from JuMP for all time steps.\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.constrain_KVL","page":"Methods","title":"BranchFlowModel.constrain_KVL","text":"constrain_KVL(m, net::Network{MultiPhase})\n\nAdd the voltage drop definintions between busses.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.reduce_tree!","page":"Methods","title":"CommonOPF.reduce_tree!","text":"reduce_tree!(p::Inputs{SinglePhase})\n\ncombine any line sets with intermediate busses that have indegree == outdegree == 1 and is not a load bus into a single line\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\nreduce_tree!(p::Inputs{MultiPhase})\n\ncombine any line sets with intermediate busses that satisfy      1. indegree == outdegree == 1     2. is not a load bus and      3. has same phases in as out  into a single line.\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.trim_tree!","page":"Methods","title":"CommonOPF.trim_tree!","text":"trim_tree!(p::Inputs)\n\nTrim any branches that do not contain load busses.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.make_graph","page":"Methods","title":"CommonOPF.make_graph","text":"make_graph(edges::AbstractVector)\n\nreturn SimpleDiGraph by inferring busses from edges with the dicts for bus => int and int => bus (because Graphs.jl only works with integer nodes)\n\njulia> g[\"13\", :bus]\n10\n\njulia> g[13, :bus]\n\"24\"\n\njulia> get_prop(g, :int_bus_map)[13]\n\"24\"\n\n\n\n\n\nmake_graph(busses::AbstractVector{String}, edges::AbstractVector)\n\nreturn SimpleDiGraph with the dicts for bus => int and int => bus (because Graphs.jl only works with integer nodes)\n\njulia> g[\"13\", :bus]\n10\n\njulia> g[13, :bus]\n\"24\"\n\njulia> get_prop(g, :int_bus_map)[13]\n\"24\"\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.leaf_busses","page":"Methods","title":"CommonOPF.leaf_busses","text":"leaf_busses(p::Inputs)\n\nreturns Vector{String} containing all of the leaf busses in p.busses\n\n\n\n\n\n","category":"function"},{"location":"methods/#BranchFlowModel.solve_metagraph!","page":"Methods","title":"BranchFlowModel.solve_metagraph!","text":"solve_metagraph!(mg::MetaGraphsNext.MetaGraph, builder::Function, tol::T; α::T=0.5, verbose=false) where T <: Real\n\nGiven a MetaGraphsNext.MetaGraph and a JuMP Model builder method iteratively solve the models until the tol is met for the differences provided by BranchFlowModel.get_diffs. \n\nThe builder must accept only one argument of type CommonOPF.AbstractNetwork that returns  a JuMP.AbstractModel. Each model returned from the builder is stored as an :m property in  each vertex of mg.\n\nnote: Note\ntol is compared to the maximum absolute value of all the p, q, and v differences.\n\n\n\n\n\nsolve_metagraph!(mg::MetaGraphsNext.MetaGraph, builder::Function, tols::Vector{T}; α::T=0.5, verbose=false) where T <: Real\n\nGiven a MetaGraphsNext.MetaGraph and a JuMP Model builder method iteratively solve the models until the tols are met for the differences provided by BranchFlowModel.get_diffs. \n\nThe builder must accept only one argument of type CommonOPF.AbstractNetwork that returns  a JuMP.AbstractModel. Each model returned from the builder is stored as an :m property in  each vertex of mg.\n\nnote: Note\nThe tols should have a length of three. The first value is compared to the maximum absolute difference in real power, the second for reactive power, and the third for |v|. All differences are calculated at the leaf/substation connections.\n\n\n\n\n\nsolve_metagraph!(mg::MetaGraphsNext.MetaGraph, builder::Dict{Int64, Function}, tols::Vector{T}; α::T=0.5, verbose=false) where T <: Real\n\nGiven a MetaGraphsNext.MetaGraph and a JuMP Model builder method iteratively solve the models until the tols are met for the differences provided by BranchFlowModel.get_diffs. The builder dict is used to build each model for the corresponding vertex key.\n\nEach function in the builder dict must accept only one argument of type CommonOPF.AbstractNetwork that returns a JuMP.AbstractModel. Each model returned from the builder function is stored as an :m property in each vertex of mg.\n\nnote: Note\nThe tols should have a length of three. The first value is compared to the maximum absolute difference in real power, the second for reactive power, and the third for |v|. All differences are calculated at the leaf/substation connections.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.reg_busses","page":"Methods","title":"CommonOPF.reg_busses","text":"reg_busses(p::Inputs)\n\nAll of the regulated busses, i.e. the second bus in the regulated edges\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.remove_bus!","page":"Methods","title":"CommonOPF.remove_bus!","text":"remove_bus!(j::String, p::Inputs{SinglePhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\nremove_bus!(j::String, p::Inputs{MultiPhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\n","category":"function"},{"location":"math/#Single-Phase-BranchFlowModel","page":"Math","title":"Single Phase BranchFlowModel","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"From [1]","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"Notation:","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"P_ij real power flow from node i to node j\np_j real power injection on node j\n`\\\\mathcal{N}^+ set of all nodes in network except the source\nw_j voltage magnitude squared on node j\nell_ij current magnitude squared  from node i to node j","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"beginaligned\nP_ij - r_ij ell_ij + p_j = sum_kjrightarrow k P_jk  forall j in mathcalN^+ \nQ_ij - x_ij ell_ij + q_j = sum_kjrightarrow k Q_jk  forall j in mathcalN^+ \nw_j = w_i - 2 r_ij P_ij - 2 x_ij Q_ij + (r_ij^2 + x_ij^2) ell_ij  forall j in mathcalN^+ \nw_i ell_ij = P_ij^2 + Q_ij^2 forall (ij) in mathcalE \n(v_jmin)^2 le w_j le (v_jmax)^2  forall j in mathcalN^+ \nendaligned","category":"page"},{"location":"math/#Three-Phase-BranchFlowModel","page":"Math","title":"Three Phase BranchFlowModel","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"TODO","category":"page"},{"location":"math/#References","page":"Math","title":"References","text":"","category":"section"},{"location":"math/#[1]","page":"Math","title":"[1]","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"Baran, Mesut E., and Felix F. Wu. \"Optimal capacitor placement on radial distribution systems.\" IEEE Transactions on power Delivery 4.1 (1989): 725-734. Chicago\t","category":"page"},{"location":"#BranchFlowModel.jl","page":"User Documentation","title":"BranchFlowModel.jl","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"BranchFlowModel builds the branch flow constraints using JuMP.  The intent of this package is to allow users to build mathematical programs that include BranchFlowModel constraints. No objective is added to the JuMP model in this package and so solving any problem defined by the constraints built by BranchFlowModel.jl is a feasibility problem. Dictionaries of constraints are provided so that one can delete and/or modify the base constraints to fit their problem.","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"warning: Warning\nThis package is under development. Contributions are welcome via fork and pull request.","category":"page"},{"location":"#Inputs","page":"User Documentation","title":"Inputs","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"There are two methods for creating Inputs:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Using openDSS files\nProviding the network topology","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Inputs(::String, ::String)\nInputs(::AbstractVector{<:Tuple}, ::AbstractVector{<:AbstractString}, ::AbstractVector{<:Real}, ::AbstractVector{<:AbstractVector}, ::String)","category":"page"},{"location":"#CommonOPF.Inputs-Tuple{String, String}","page":"User Documentation","title":"CommonOPF.Inputs","text":"Inputs(\n    dssfilepath::String, \n    substation_bus::String;\n    Pload::AbstractDict=Dict(), \n    Qload::AbstractDict=Dict(), \n    Sbase=1, \n    Vbase=1, \n    v0, \n    v_lolim=0.95, \n    v_uplim=1.05,\n    Ntimesteps=1, \n    P_up_bound=1e4,\n    Q_up_bound=1e4,\n    P_lo_bound=-1e4,\n    Q_lo_bound=-1e4,\n    relaxed=true,\n    extract_phase::Int=0  # set to 1, 2, or 3\n)\n\nInputs constructor that parses a openDSS file for the network. If Pload and Qload are not provided then the loads are also parsed from the openDSS file.\n\nIf extract_phase is set to 1, 2, 3 then the loads for that phase are put into Pload and Qload and the impedance values are set to the positive sequence impedance for each line. Note that single phase lines and two phase lines do not have positive sequence definitions but single phase lines only have one impedance value anyway and for two phase lines we use  zmutual = z12 and zself = 1/2(z11 + z22).\n\n\n\n\n\n","category":"method"},{"location":"#CommonOPF.Inputs-Tuple{AbstractVector{<:Tuple}, AbstractVector{<:AbstractString}, AbstractVector{<:Real}, AbstractVector{<:AbstractVector}, String}","page":"User Documentation","title":"CommonOPF.Inputs","text":"Inputs(\n    edges::Array{Tuple}, \n    linecodes::Array{String}, \n    linelengths::Array{Float64}, \n    phases::Vector{Vector},\n    substation_bus::String;\n    Pload, \n    Qload, \n    Sbase=1, \n    Vbase=1, \n    Zdict, \n    v0, \n    v_lolim=0.95, \n    v_uplim=1.05,\n    Ntimesteps=1, \n    P_up_bound=1e4,\n    Q_up_bound=1e4,\n    P_lo_bound=-1e4,\n    Q_lo_bound=-1e4,\n    Isquared_up_bounds=Dict{String, Float64}(),\n    relaxed=true\n)\n\nLowest level Inputs constructor (the only one that returns the Inputs struct). \n\nnote: Note\nThe real and reactive loads provided are normalized using Sbase.\n\n\n\n\n\n","category":"method"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Both of the Inputs functions return a mutable Inputs struct:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Inputs","category":"page"},{"location":"#CommonOPF.Inputs","page":"User Documentation","title":"CommonOPF.Inputs","text":"mutable struct Inputs{T<:Phases} <: AbstractInputs\n    edges::Array{Tuple, 1}\n    linecodes::Array{String, 1}\n    linelengths::Array{Float64, 1}\n    busses::Array{String}\n    phases::Vector{Vector}\n    substation_bus::String\n    Pload::Dict{String, Any}\n    Qload::Dict{String, Any}\n    Sbase::Real\n    Vbase::Real\n    Ibase::Real\n    Zdict::Dict{String, Dict{String, Any}}\n    v0::Real\n    v_lolim::Real\n    v_uplim::Real\n    Zbase::Real\n    Ntimesteps::Int\n    pf::Float64\n    Nnodes::Int\n    P_up_bound::Float64\n    Q_up_bound::Float64\n    P_lo_bound::Float64\n    Q_lo_bound::Float64\n    Isquared_up_bounds::Dict{String, <:Real}\n    phases_into_bus::Dict{String, Vector{Int}}\n    relaxed::Bool\n    edge_keys::Vector{String}\n    regulators::Dict\n    shunt_susceptance::Dict\nend\n\nInputs\n\nedges Vector{Tuple} e.g. [(\"0\", \"1\"), (\"1\", \"2\")]\nlinecodes vector of string keys for the Zdict (impedance values for lines). When using an OpenDSS model a linecode is the name in New linecode.name\nlinelengths vector of floats to scale impedance values\nbusses vector of bus names\nphases vector of vectors with ints for the line phases (e.g. [[1,2,3], [1,3], ...])\nPload dict with busses for keys and uncontrolled real power loads (positive is load) by phase and time\nQload dict with busses for keys and uncontrolled reactive power loads (positive is load) by phase and time\nSbase base apparent power for network, typ. feeder capacity. Used to normalize all powers in model\nVbase base voltage for network, used to determine Zbase = Vbase^2 / Sbase\nIbase = Sbase / (Vbase * sqrt(3))\nZdict dict with linecodes for keys and subdicts with \"xmatrix\" and \"zmatrix\" keys with per unit length values. Values are divided by Zbase and multiplied by linelength in mathematical model.\nv0 slack bus reference voltage\n\nTODO Zdict example\n\nTODO test against simple model to make sure scaling is done right\n\nnote: Note\nThe edges, linecodes, phases, edge_keys, and linelengths are in mutual order (i.e. the i-th value in each list corresponds to the same line)\n\n\n\n\n\n","category":"type"},{"location":"#Building-a-Model","page":"User Documentation","title":"Building a Model","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"The build_ldf! function takes a JuMP.Model and Inputs struct as its two arguments and adds the variables and constraints:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"build_model!","category":"page"},{"location":"#BranchFlowModel.build_model!","page":"User Documentation","title":"BranchFlowModel.build_model!","text":"build_model!(m::JuMP.AbstractModel, net::Network{SinglePhase})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_variables(m, net)\nconstrain_power_balance(m, net)\nconstrain_substation_voltage(m, net)\nconstrain_KVL(m, net)\nif relaxed\n    constrain_cone(m, net)\nelse\n    constrain_bilinear(m, net)\nend\n\n\n\n\n\nbuild_model!(m::JuMP.AbstractModel, net::Network{MultiPhase})\n\nAdd variables and constraints to m using the values in net. Calls the following functions:\n\nadd_variables(m, net)\nconstrain_power_balance(m, net)\nconstrain_substation_voltage(m, net)\nconstrain_KVL(m, net)\n\n\n\n\n\n","category":"function"},{"location":"#Variables","page":"User Documentation","title":"Variables","text":"","category":"section"},{"location":"#Single-Phase-Model","page":"User Documentation","title":"Single Phase Model","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Let m be the JuMP.Model provided by the user, then the variables can be accessed via:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"m[:vsqrd] voltage magnitude squared, indexed on busses\nm[:p0], m[:q0] net real, reactive power injection at the substation bus\nm[:Pij], m[:Qij] net real, reactive line flow, indexed on edges\nm[:lij] current magnitude squared, indexed on edges","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"After a model has been solved using JuMP.optimize! variable values can be extracted with JuMP.value. For more see Getting started with JuMP.","category":"page"},{"location":"#MultiPhase-Model","page":"User Documentation","title":"MultiPhase Model","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"The definition of the multiphase variables is done in model_multi_phase.jl as follows:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"# voltage squared is Hermitian\nm[:w] = Dict{Int64, S}()\n# current squared is Hermitian\nm[:l] = Dict{Int64, S}()\n# complex line powers (at the sending end)\nm[:Sij] = Dict{Int64, S}()\n# complex net powers injections \nm[:Sj] = Dict{Int64, S}()\n# Hermitian PSD matrices\nm[:H] = Dict{Int64, S}()","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"where the first key is for the time index and the inner Dict:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"S = Dict{String, AbstractVecOrMat}","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"has string keys for either bus names or edge names, (which are stored in the Inputs as Inputs.busses and Inputs.edge_keys respectively).","category":"page"},{"location":"#Accessing-and-Modifying-Constraints","page":"User Documentation","title":"Accessing and Modifying Constraints","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Let the JuMP.Model provided by the user be called m.  Some constraints are stored in the model dict as anonymous constraints with symbol keys.","category":"page"},{"location":"#Power-Injections","page":"User Documentation","title":"Power Injections","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"BranchFlowModel.jl uses the convention that power injections are positive (and loads are negative). If no load is provided for a given bus (and phase) then the real and reactive power injections at that bus (and phase) are set to zero with an equality constraint.","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"All power injection constraints are stored in m[:injection_equalities]. The constraints are indexed in the following order:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"by bus name (string), as provided in Inputs.busses;\nby \"p\" or \"q\" for real and reactive power respectively;\nby phase number (integer); and\nby time (integer).","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"For example, m[:injection_equalities][\"680\"][\"p\"][2][1] contains the constraint reference for the power injection equality constraint for bus \"680\", real power, in time step 2, on phase 1.","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"If one wished to replace any constraint one must first delete the constraint using the delete function. For example:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"delete(m, m[:cons][:injection_equalities][\"680\"][\"p\"][1])","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Note that the time index was not provided in the delete command in this example, which implies that the equality constraints for all time steps were deleted. One can also delete individual time step constraints by providing the time index.","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"The deleted constraints can then be replaced with a new set of constraints. For example:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"m[:cons][:injection_equalities][\"680\"][\"p\"][1] = @constraint(m, [t in 1:p.Ntimesteps],\n    m[:Pj][\"680\",1,t] == -1e3 / p.Sbase\n)","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"where p is short for \"parameters\" and is the Inputs struct for the problem of interest. Note that it is not necessary to store the new constraints in the m[:cons][:injection_equalities].","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"See the JuMP documentation for more on deleting constraints.","category":"page"},{"location":"#Results","page":"User Documentation","title":"Results","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Results(m::JuMP.AbstractModel, p::Inputs{SinglePhase}; digits=8)","category":"page"}]
}
